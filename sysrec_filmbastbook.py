# -*- coding: utf-8 -*-
"""SysRec_FilmBastBook.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11_CUPsrz-5xuvwVIw73WxHB9UiZkYTp8

# Laporan Proyek Machine Learning -  Rekomendasi Film
by Handerson Loriano
"""

# google colab settings
from google.colab.data_table import DataTable
DataTable.max_columns = 120

# Import Lib
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

"""## Project Overview
### Pendahuluan
[<sup>[1]</sup>](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9269752/)Sistem rekomendasi Film bertujuan untuk memberikan sugesti kepada *customer* berdasarkan fitur-fitur yang disukai pada *Customer*. Sistem rekomendasi yang terbaik adalah mampu memberikan sugesti film yang cocok dengan kesamaan *Customer* dalam performa yang tinggi.

Seiringan dengan perkembangan teknologi yang pesat, beberapa pelaku bisnis perusahaan ditantang untuk memberikan rekomendasi cepat dan relevan. Untuk itu sistem rekomendasi dibutuhkan untuk memecahkan masalah yang kompleks karena, penyesuaian dari masing-masing pihak pengguna berbeda-beda, waktu, lingkungan dan juga kebudayaannya masing-masing.

Contohnya, Sistem rekomendasi *youtube* (Nama popularnya '*Youtube Algorithm*') merekomendasikan pengunjung yang berada disuatu tempat

![image](https://drive.google.com/uc?id=1Le8PvVE9AHgEdbP1xiCPprB5m64VS6Rj&export=download)

Hal ini menyebabkan pengguna ingin melihat bagian yang ingin dieksplorasi dan meningkatkan peluang untuk video yang banyak ingin dilihat. Tentunya ini akan menambah *revenue* bagi pemilik video dan *Channel*-nya

### Rumusan Permasalahan Awal
1. Mempengaruhi seseorang dengan kesamaan relevansi dalam waktu singkat
2. Analisa dari sudut pandang *customer* sangatlah sulit :
  - *Customer* memiliki pandangan yang berbeda-beda dan data yang sangat besar
  - *Customer* tidak semua data bisa menjadi relevan untuk diolah sistem rekomendasi karena, beberapa data-data yang dimiliki *customer* tidak bisa dijadikan acuan yang tepat.

## Business Understanding
Bila ingin merekomendasi suatu film tentunya harus ada kedekatan konten yang ingin dipertunjukan dari segi manapun. Misalnya, bila seseorang menikmati film bergenre '*Animation*' tentunya ia akan memilih film '*Animation*' yang lainnya. Tentu saja penikmat film bisa saja berubah, bisa saja ia ingin melihat film tentang '*Documentary*'. Akan tetapi, rekomendasi harus mendekati diantara '*Animation*' dan '*Documentary*' maka, penikmat film akan selalu menikmatinya

### Problem Statements
1. *Genre* apa yang memiliki rating tertinggi?
2. Apa rekomendasi film untuk orang yang ber*genre* *Horror*?

### Goals
1. Mengetahui '*Genre*' yang mempunyai rating tertinggi
2. Membuat model *machine learning Content-Based filtering* yang dapat memprediksi film rekomendasi dan diukur berdasarkan metrik *Precision @K*.
Semakin banyak *genre* yang mempunyai kesamaan pada film maka semakin besar peluang penikmat film akan menonton film ber*genre* kesukaannya.

Pada contoh ini adalah film ber*genre* horror

## Data Understanding
Ini adalah tahapan yang dilakukan pada *Data Understanding* :
1. Melakukan *Data Loading* supaya bisa membaca sumber dari yang sudah ada dan mengikuti arti data yang baik
2. Mendeskripsikan data supaya bisa melihat pola apa saja yang bisa disiapkan pada tahapan *Data Preparation*
3. Menyaring *missing Value* dan *Outliers*
4. Melakukan *EDA Univariate analysis* supaya dapat melihat total data yang dapat lihat
5. Melakukan *EDA Multivariate analysis* untuk fitur kategorikal untuk mencari hubungan yang sesuai

Info Dataset :
1. Nama Dataset : NetflixOriginals
2. total : 584

Berikut ini adalah maksud / arti dari nama kolom tersebut :
1. *Title* = judul film
2. *Genre* = jenis film
3. *Premiere* = tanggal film tayangan
4. *Runtime* = lamanya film berjalan (dalam menit)
5. *IMDB Score* = nilai rating film dari IMDB (0 - 10)
6. *Language* = bahasa film tayangan

proses yang akan dilakukan pada tahapan ini adalah :
1. *Data loading*
2. *Exploratory Data Analysis*

Pada penggalian data pada tahap *Exploratory Data analysis* :
1. Menemukan Kolom cell *Language* yang sepertinya berganda dan beberapa dari bahasa tersebut ditemukan menyatu dengan satu sama lain. Data unik ini bisa dinamakan *multilabel classification*, yang dimana beberapa data menjadi satu tapi masih terkaitan dengan maknanya. Sehingga bisa dilihat pada perhitungan *univariate analysi*s lumayan banyak dan komplex
2. Uniknya pada data ini memiliki korelasi lemah terhadap '*Runtime*' dan '*Premiere*'. Ini berarti, penayangan tanggal film-film yang telat berpotensi mempunyai film dengan jangka tayang yang lebih lama dari tanggal-tanggal yang sebelumnya

### Data Loading
Data yang berasal dari sumber ini[<sup>[6]</sup>](https://www.kaggle.com/datasets/luiscorter/netflix-original-films-imdb-scores) :
1. setelah diunduh, harus diunggah ke *google drive*
2. dan mengubah akses supaya bisa pakai di *google colab*

Pada tahap *data loading* akan melakukan pengambilan data dan menyeleksi kolom yang perlu diperhatikan
"""

!mkdir 'content'
!wget --no-check-certificate 'https://docs.google.com/uc?export=download&id=1TqlJPWPfzy2pcPcMzV5SjVn4OzZw_vIP&confirm=t' -O './content/NetflixOriginals.csv'
dataframe_recfilm = pd.read_csv("./content/NetflixOriginals.csv", encoding = "ISO-8859-1")

dataframe_recfilm

"""### Exploratory Data Analysis
Ini adalah tahapan yang akan dilakukan :
1. Mendeskripsikan variabel kolom
2. menganalisis untuk mencari *missing value* dan *outliers*
3. Menggunakan cara *univariate analysis* untuk analisis data dan menjawab pertanyaan bisnis

#### Exploratory Data Analysis - Deskripsi Variabel
"""

dataframe_recfilm

dataframe_recfilm.info()

dataframe_recfilm.describe(include="all")

dataframe_recfilm.corr(method ='pearson', numeric_only=True)

"""#### Exploratory Data Analysis - Missing Value & outliers
1. Melihat *missing value*. Tidak ada *missing value* yang relevan
2. Mengubah data tanggal menjadi angka yang bisa diproses untuk pengecekan *outliers*
3. Memproses data *numerical* yang berada di jangkauan *outlier* memakai, metode *IQR*. Untuk memproses value yang dapat mengacaukan pada tahap *modeling*
"""

# melihat missing value
dataframe_recfilm.isnull().sum()

dataframe_recfilm.shape

dataframe_recfilm

# mengubah date menjadi angka
# membetulkan titik dan koma
for col, row in dataframe_recfilm.iterrows() :
  if '.' in dataframe_recfilm.at[col, 'Premiere']  :
    dataframe_recfilm.at[col, 'Premiere'] = dataframe_recfilm.at[col, 'Premiere'].replace('.', ",")

dataframe_recfilm["Premiere"] = pd.to_datetime(dataframe_recfilm["Premiere"], format='%B %d, %Y' )
dataframe_recfilm['Premiere'] = dataframe_recfilm['Premiere'].apply(lambda x: x.value)

# melihat outliers Premiere
sns.boxplot(x=dataframe_recfilm['Premiere'])

dataframe_recfilm.shape

# menangani outliers Premiere
Q1 = dataframe_recfilm.quantile(0.25, numeric_only=True)
Q3 = dataframe_recfilm.quantile(0.75, numeric_only=True)
IQR=Q3-Q1
qcombine = dataframe_recfilm.lt(Q1-1.5*IQR) | dataframe_recfilm.gt(Q3+1.5*IQR)
datadexing = qcombine.any(axis=1)
dataframe_recfilm_l1 =dataframe_recfilm[~datadexing]

dataframe_recfilm_l1.shape

# menyesuaikan outliers Runtime
whis_runtime = 3.7
sns.boxplot(x=dataframe_recfilm['Runtime'], whis=whis_runtime)

dataframe_recfilm_l1.shape

# menangani outliers Runtime
Q1 = dataframe_recfilm_l1.quantile(0.25, numeric_only=True)
Q3 = dataframe_recfilm_l1.quantile(0.75, numeric_only=True)
IQR=Q3-Q1
qcombine = dataframe_recfilm_l1.lt(Q1-whis_runtime*IQR) | dataframe_recfilm_l1.gt(Q3+whis_runtime*IQR)
datadexing = qcombine.any(axis=1)
dataframe_recfilm_l2 =dataframe_recfilm_l1[~datadexing]

dataframe_recfilm_l2.shape

sns.boxplot(x=dataframe_recfilm_l2['Runtime'])

sns.boxplot(x=dataframe_recfilm['Runtime'], whis=whis_runtime)

# melihat outliers IMDB Score
sns.boxplot(x=dataframe_recfilm_l2['IMDB Score'])

"""#### Exploratory Data Analysis - Univariate Analysis
1. Memproses *outliers* untuk *Language*.
2. Memproses *outliers* untuk *Genre*.

Terlihat ada beberapa data pada kolom '*Language*' terlihat ganda dan beberapa *variable* dari kolom tersebut sama dengan beberapa *variable* yang sendiri.

Ini adalah sifat dari *multilabel classification* yang nanti akan diolah pada tahap *data preparation*. untuk saat ini, mencari jawaban dari *business understanding*

|Data|Value|
|:------|:------|
|Title|David Attenborough : ALife on Our Planet|
|Genre|Documentary|
|Premiere|1601769600000000000|
|Runtime|83|
|IMDB Score|9.0|
|Language|English|

Terlihat genre '*Documentary*' mempunyai IMDB Score yang paling tinggi yang berjudul David Attenborough: A Life on Our Planet
"""

dataframe_recfilm_l2

numerical_features = ['Premiere', 'Runtime', 'IMDB Score']
categorical_features = ['Title', 'Genre', 'Language']

feature = categorical_features[1]
count = dataframe_recfilm_l2[feature].value_counts()
percent = 100*dataframe_recfilm_l2[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature, figsize=(20,10));

feature = categorical_features[2]
count = dataframe_recfilm_l2[feature].value_counts()
percent = 100*dataframe_recfilm_l2[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature, figsize=(20,10));

dataframe_recfilm.iloc[dataframe_recfilm['IMDB Score'].idxmax()]

"""#### Exploratory Data Analysis - Multivariate Analysis
Setelah kita lihat, tidak ada korelasi *variable* kolom dengan yang lain secara nyata
"""

sns.set(font_scale=2)

cat_features = dataframe_recfilm.select_dtypes(include='object').columns.to_list()

for col in cat_features:
  sns.catplot(x="Premiere", y=col, kind="bar", dodge=False, height = 50, aspect = 1,  data=dataframe_recfilm, palette="Set3")
  plt.title("Korelasi Data 'Premiere terhadap - {}".format(col))

for col in cat_features:
  sns.catplot(x="Runtime", y=col, kind="bar", dodge=False, height = 50, aspect = 1,  data=dataframe_recfilm, palette="Set3")
  plt.title("Korelasi Data 'Runtime terhadap - {}".format(col))

for col in cat_features:
  sns.catplot(x="IMDB Score", y=col, kind="bar", dodge=False, height = 50, aspect = 1,  data=dataframe_recfilm, palette="Set3")
  plt.title("Korelasi Data 'IMDB Score terhadap - {}".format(col))

sns.set(font_scale=1)

sns.pairplot(dataframe_recfilm, diag_kind = 'kde')

plt.figure(figsize=(10, 8))
correlation_matrix = dataframe_recfilm.corr(numeric_only=True).round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""## Data Preparation
Beberapa data sudah yang diproses untuk *missing value* dan *outliers* pada tahap *Exploratory data analysis* :
1. Menggunakan Metode *IQR* untuk mengatasi *outliers* pada kolom *Runtime* dan *Premiere*.
2. Tidak ada *Missing Value* atau data yang kosong. Setelah, menggunakan '*.isnull().sum()*' pada library pandas.
3. Mengubah kolom *Premiere* menjadi tanggal dan diolah memakai *value* untuk dianalisa pada tahapan *Data Understanding*
4.  Lalu, ini adalah tahapan yang digunakan pada *Data Preparation*</br>
  Membersihkan data yang sudah dianalisa pada tahapan *Exploratory Data Analysis*
    - Kesalahan pada '*Making-of*'. Tidak tahu apakah ini jenis film bertipe '*Documentary*', '*Behind the Screen*' atau sebagainya. Maka, dari itu bisa dihapus
    - Kesalahan penulisan 'Thia'. Tidak ada bahasa yang bernama Thia. Jadi harus diubah dan bisa menganalisa memakai *google* menjadi '*Thai*'



"""

#Menghapus data 'Making-of'
dataframe_recfilm_l2 = dataframe_recfilm_l2.drop(dataframe_recfilm_l2[dataframe_recfilm_l2['Genre'] == 'Making-of'].index)

# memperbaiki kesalahan penulisan Thia >> Thai
for col, row in dataframe_recfilm_l2.iterrows() :
  if 'Thia' in dataframe_recfilm_l2.at[col, 'Language']  :
    dataframe_recfilm_l2.at[col, 'Language'] = dataframe_recfilm_l2.at[col, 'Language'].replace('Thia', "Thai")

dataframe_recfilm_l2

"""## Modelling
Sistem rekomendasi akan menampilkan 10 hal yang direkomendasikan dan menggunakan model Pendekatan *Content Based Filtering*.

Kolom yang digunakan adalah *Genre* karena, Ini adalah hal yang membutuhkan kesesuaian penikmat film. Bila mereka ingin melihat film layaknya bahasa inggris, bisa mengatur nilai k didalam fungsi

Dikutip dari halaman page *SKLearn* tentang [*TfidfVectorizer*](https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html) adalah Mengkonversikan kumpulan kata-kata dan dijadikan *matrix of TF-IDF features* (Fitur ini adalah fitur yang paling tepat karena, pada Kolom '*Genre*' juga mempunyai *multilabel classification*). Lalu, mengecek kesamaan memakai [*Cosine Similarity*](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.pairwise.cosine_similarity.html) pada sampel matriks x dan y -nya

Ini adalah tahap yang dibuat :
1. Meng*initilize* dan Memakai *TFIDF-Vectorizer* untuk melihat kata-kata yang dikategorikan
2. Menggunakan *Cosine Similarity* untuk menghitung derajat Kesamaan-nya
3. Membuat fungsi rekomendasi dari dataset pada *Data Preparation*

Pada perhitungan *TFIDF-Vectorizer* memakai perhitungan *default*nya dan *Cosine Similarity* juga memakai perhitungan *default*nya saja.

### Hasil
Inilah Hasilnya bila seseorang pernah melihat film "*The Larva Island Movie*"

|index|Title|Genre|Language|Runtime|Premiere|IMDB Score|
|---|---|---|---|---|---|---|
|0|Octonauts & the Caves of Sac Actun|Animation|English|72|14/Aug 2020|6\.2|
|1|The Willoughbys|Animation/Comedy/Adventure|English|90|22/Apr 2020|6\.4|
|2|Fearless|Animation/Superhero|English|89|14/Aug 2020|4\.9|
|3|Invader Zim: Enter the Florpus|Animation/Science Fiction|English|71|16/Aug 2019|7\.5|
|4|Over the Moon|Animation/Musical/Adventure|English|95|23/Oct 2020|6\.4|
|5|Klaus|Animation/Christmas/Comedy/Adventure|English|97|15/Nov 2019|8\.2|
|6|The Babysitter: Killer Queen|Comedy/Horror|English|102|10/Sep 2020|5\.8|
|7|The After Party|Comedy|English|89|24/Aug 2018|5\.8|
|8|Rising High|Satire|German|94|17/Apr 2020|5\.8|
|9|The Claus Family|Fantasy|Dutch|96|07/Dec 2020|5\.8|

### Content-Based Filtering
"""

dataframe_recfilm_l2

# Inisialisasi TfidfVectorizer
tfidfv = TfidfVectorizer()
tfidfv.fit(dataframe_recfilm_l2['Genre'])
tfidfv.get_feature_names_out()

tfidf_matrix = tfidfv.fit_transform(dataframe_recfilm_l2['Genre'])
tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tfidfv.get_feature_names_out(),
    index=dataframe_recfilm_l2.Title
).sample(22, axis=1).sample(10, axis=0)

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

cosine_sim_df = pd.DataFrame(cosine_sim, index=dataframe_recfilm_l2['Title'], columns=dataframe_recfilm_l2['Title'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada tiap genre
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

def filmTitle_recommendations(Title, similarity_data=cosine_sim_df, items=dataframe_recfilm_l2[['Title', 'Genre', 'Language', 'Runtime', 'Premiere', 'IMDB Score']], k=5):
    index = similarity_data.loc[:,Title].to_numpy().argpartition(range(-1, -k, -1))
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(Title, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

dataframe_recfilm_l2.loc[dataframe_recfilm_l2['Genre'] == 'Drama']

dataframe_recfilm_l2.loc[dataframe_recfilm_l2['Genre'].str.contains('Animation', na=False) ]

dataframe_recfilm_l2[dataframe_recfilm_l2.Title.eq('Winter on Fire: Ukraine\'s Fight for Freedom')]

datarec = filmTitle_recommendations('The Larva Island Movie', k=10)
datarec['Premiere'] = pd.to_datetime(datarec['Premiere']).dt.strftime('%d/%b %Y')
datarec

"""## Evaluation
Ini adalah tahapan yang akan dilakukan oleh evaluation :
1. Membuat metrik evaluasi berdasarkan *Precision @K* [<sup>[3]</sup>](https://datascience.stackexchange.com/questions/92247/precisionk-and-recallk)

  > $\texttt{Recommender system precision: }P = \frac{\texttt{# of our recommendations that are relevant}}{\texttt{# of items we recommend}}$

  Sederhananya, Fungsi ini menghitung berapa jumlah rekomendasi yang relevan dibagi dengan semua rekomendasi. $P$ adalah persentase yang dimana semakin mendekati 100% adalah mesin rekomendasi yang terbaik.

  Rekomendasi Persen = jumlah total rekomendasi yang relevan / jumlah semua item rekomendasi
2. Membuat perbandingan antar *genre* dan persentase yang tepat

Perhitungan ini efektif mengevaluasi model *machine-learning* yang memakai lebih dari satu algoritma *machine-learning*. Akan tetapi, evaluasi dapat membias kearah sistem rekomendasi pada salah satu *Genre*. Maka, bisa disempurnakan memakai perhitungan beberapa *Genre*

Terlihat bila data pada genre yang mempunyai dataset sedikit perhitungan persentase presisi menurun ini dikarenakan data yang digunakan sangat kurang.

Tentunya Perhitungan *Precision @K* ini masih membias ke konten yang terbanyak oleh karena itu bisa dihitung menggunakan rata-rata dari beberapa *genre* :

|Genre|Persentase|
|:---|---:|
|Animation|60%|
|Documentary|100%|
|Horror|100%|
|Musical|60%|

lalu perhitungannya :
> $\\P = \frac{\texttt{60% + 100% + 100% + 60%}}{4}$

> $\\P = \texttt{80%}$

Terlihat pada Genre '*Documentary*' dan '*Horror*' Memberikan evaluasi yang 100% karena, dataset yang dilatih banyak dari *Genre* '*Documentary*' dan '*Horror*'. Sedangkan, pada *genre* *Animation* dan *Musical* memberikan evaluasi 60%. Maka untuk itu, dipakailah perhitungan rata-rata antara banyak *genre* sehingga perhitungan tersebut mengurangi bias dalam evaluasi '*Precision @K*'

Hasilnya evaluasi sistem rekomendasinya adalah $\pm$ 80%. Hasil yang cukup bagus dan relevan.

Inilah rekomendasi seseorang untuk melihat film *horror*

|index|Title|Genre|Language|Runtime|Premiere|IMDB Score|
|---|---|---|---|---|---|---|
|0|Apostle|Horror-thriller|English|129|12/Oct 2018|6\.3|
|1|The Perfection|Horror-thriller|English|90|24/May 2019|6\.1|
|2|Gerald's Game|Horror thriller|English|103|29/Sep 2017|6\.5|
|3|Nobody Sleeps in the Woods Tonight|Horror|Polish|103|28/Oct 2020|4\.8|
|4|Cadaver|Horror|Norwegian|86|22/Oct 2020|5\.1|
|5|Rattlesnake|Horror|English|85|25/Oct 2019|4\.6|
|6|I Am the Pretty Thing That Lives in the House|Horror|English|89|28/Oct 2016|4\.6|
|7|In the Tall Grass|Horror|English|101|04/Oct 2019|5\.4|
|8|Bulbbul|Horror|Hindi|94|24/Jun 2020|6\.6|
|9|Things Heard & Seen|Horror|English|121|29/Apr 2021|5\.3|

"""

# Membuat data evaluasi
def evaluate_recommendationData (datarec, contain_genre) :
  # diff len
  p_recrel = len(datarec.loc[datarec['Genre'].str.contains(contain_genre, na=False)])
  # get all len
  p_allrec = len(datarec)

  return p_recrel / p_allrec

dataframe_recfilm_l2.loc[dataframe_recfilm_l2['Genre'].str.contains('Musical', na=False) ]

# Contoh data rekomendasi film yang bergenre animation
datarec = filmTitle_recommendations('The Larva Island Movie', k=10)
datarec['Premiere'] = pd.to_datetime(datarec['Premiere']).dt.strftime('%d/%b %Y')
datarec

print(evaluate_recommendationData(datarec, 'Animation') * 100," %")

datarec = filmTitle_recommendations("Hello Privilege. It's Me, Chelsea", k=10)
datarec['Premiere'] = pd.to_datetime(datarec['Premiere']).dt.strftime('%d/%b %Y')
datarec

print(evaluate_recommendationData(datarec, 'Documentary') * 100," %")

# Death Note is horror? Really? it should be Drama politcal and action right? Dicoding...
datarec = filmTitle_recommendations("Death Note", k=10)
datarec['Premiere'] = pd.to_datetime(datarec['Premiere']).dt.strftime('%d/%b %Y')
datarec

print(evaluate_recommendationData(datarec, 'Horror') * 100," %")

datarec = filmTitle_recommendations("Como Caído del Cielo", k=10)
datarec['Premiere'] = pd.to_datetime(datarec['Premiere']).dt.strftime('%d/%b %Y')
datarec

print(evaluate_recommendationData(datarec, 'Musical') * 100," %")